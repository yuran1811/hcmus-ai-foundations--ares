\subsection{Dijkstra's Algorithm}

\subsubsection{Pseudocode}
\begin{algorithm}[H]
	\caption{Dijkstra's Algorithm (\textit{start, goal})}
	\label{alg:dijkstra}
	\begin{algorithmic}[1]
	\State priority queue $\gets$ [(start, cost = 0)]
	\State distances[start] $\gets$ 0
	\While {priority queue is not empty}
		\State (node, cost) $\gets$ dequeue(priority queue)
		\If {node = goal}
			\State return distances
		\EndIf
		\ForAll {neighbor in valid moves}
			\State new cost $\gets$ cost + move cost
			\If {new cost $<$ distances[neighbor]}
				\State distances[neighbor] $\gets$ new cost
				\State enqueue(priority queue, (neighbor, new cost))
			\EndIf
		\EndFor
	\EndWhile
	\State return distances
	\end{algorithmic}
\end{algorithm}

\subsubsection{Implementation}

\subsubsection{Time and Space Complexity}

