\subsection{Breadth First Search}
\noindent Breadth First Search (BFS), as the name says, explores the search space in the increasing order of the depth and the costs of traveling from one state to another is assumed to be a positive number. Typically, this algorithm is often associated with the concept of stack and queue and pushing and popping from the stack.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{./imgs/bfs.png}
	\caption{Breadth First Search}
\end{figure}

\subsubsection{Pseudocode}
\begin{algorithm}[H]
	\caption{Breadth First Search (\textit{state, maxdepth, maxtimeout})}
	\label{alg:bfs}
	\begin{algorithmic}[1]
	\State queue $\gets$ starting position of Sokoban
	\State cost $\gets$ cost of moves
	\While {queue is not empty}
		\State Remove the first element of queue
		\If {Ares crates on target}
			\State break
		\Else
			\If {Is deadlock or depth $\geq$ maxdepth or time $\geq$ maxtimeout}
				\State pick next solution
			\Else
				\State Get valid moves for Sokoban
				\ForAll {move}
					\State Find next state
					\State Put it in queue with current cost + 1
				\EndFor
			\EndIf
		\EndIf
	\EndWhile
	\State \Return moves
	\end{algorithmic}
\end{algorithm}

\subsubsection{Implementation}

\subsubsection{Time and Space Complexity}
\textbf{Time Complexity:} $O(V + E)$, where $V$ is the number of vertices and $E$ is the number of edges. Each node and edge is processed once.

\textbf{Space Complexity:} $O(V)$ in the worst case, as the queue stores all nodes at the widest level of the graph.



